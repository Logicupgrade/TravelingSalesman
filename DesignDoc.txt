
"Submit a document with students working together on this project." 
 Daniel Hayden and Daniel Beeston
"Include a section on solution design. This should include:

Classes
Functions
inputs
outputs
functionality
Considering using UML for the classes and functions
How the main driver will function
Who is responsible for each class/function
A timeline of due dates for classes/functions
Also, describe your plan for communicating with your partner and how you intend to collaborate on your code. 
Specifically name the technologies you will use and how."

Communication Plan:
    design plan iteration 

    technologies used:
        gitHub
        texting

Responsibility distribution:    //using last names because first names are same

(Graph Class) [Beeston]
(Path Class)[Hayden]
(Driver)[Beeston] and/or [Hayden]
    (generatePaths)[Hayden]

Timeline:
//idk when good deadlines would be

Solution Design:

(Graph Class)
Description: Adjacency matrix based
    private:
	const int numVertex;	                            //will not need if list of templates
        ItemType    vertices[numVertex];	            //names of vertices, change to list of strings rather than template array?
        int         adjMatrix[numVertex][numVertex];	//Use pointer to dynamic memory instead of array? allows graph to change size
    public:
        Graph(int numVertex, ItemType newVertices[]);
	Graph(Graph &other);	

        setVertex(int vertexIndex, ItemType newVertex, int connections[]);
        ItemType getVertexAt(int index);
	int TraversePath(Path p);	                        //returns weight of path after traversal



(Path Class)	
Description: Bare bones, contains int array with each element corresponding to a vertex in a graph.
    private: 
        int         array[6] = {0,0,0,0,0,0};     //{0,x,x,x,x,0} Reno = index 0
    public:
        Path(int pathIntArray)
        void    setAtIndex(int index);
        int     getDataAtIndex(int index);


(Main file/driver)
in main():
        Graph           cityPaths;
        Stack<Path>     stackOfPaths;
        Path            aShortestPath;	//will store shortest path
	int		ShortestPathCost;	//store shortest path cost, set using Graph::TraversePath()

Functions:
	Graph	ReadGraphFromFile(std::string filename);
        bool    generatePaths(Graph g, Stack<Path> s);	
        void    findShortestPath(Graph g, Stack<Path> s);
        void    displayPaths(Stack<path> s);
        bool    writePathsToFile(std::string filename);
